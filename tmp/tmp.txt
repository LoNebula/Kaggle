# check the max height and width in challenges data
def get_max_shape_challenge(data_dict):
    hs, ws = [], []
    for section in data_dict.values():
        for phase in ['train', 'test']:
            if phase not in section:
                continue
            for pair in section[phase]:
                if 'input' in pair:
                    inp = torch.tensor(pair['input'])
                    h, w = inp.shape
                    hs.append(h)
                    ws.append(w)
                if 'output' in pair:
                    out = torch.tensor(pair['output'])
                    h, w = out.shape
                    hs.append(h)
                    ws.append(w)
    return max(hs), max(ws)

# check the max height and width in solutions data
def get_max_shape_solution(data_dict):
    hs, ws = [], []
    for section in data_dict.values():
        h = len(section)
        w = len(section[0])
        hs.append(h)
        ws.append(w)
    return max(hs), max(ws)

max_hight, max_weight = 0, 0

for data_dict in [train_challenges, eval_challenges, test_data]:
    max_h, max_w = get_max_shape_challenge(data_dict)
    max_hight = max(max_hight, max_h)
    max_weight = max(max_weight, max_w)

print("Max height and width:",max_hight, max_weight)


for data_dict in [train_solutions, eval_solutions]:
    max_h, max_w = get_max_shape_solution(data_dict)
    max_hight = max(max_hight, max_h)
    max_weight = max(max_weight, max_w)

print("Max height and width:",max_hight, max_weight)

# reshpae to max_height and max_width
def pad_matrix(x, max_height, max_width):
    return F.pad(x, (0, max_width - x.shape[1], 0, max_height - x.shape[0]), mode='constant', value=0)

def pad_all_challenges(data_dict, max_height, max_width):
    result = {}
    for key, section in data_dict.items():
        result[key] = {}
        for phase in ['train', 'test']:
            if phase not in section:
                continue
            result[key][phase] = []
            for pair in section[phase]:
                new_pair = {}
                for k, arr in pair.items():
                    arr_t = torch.tensor(arr, dtype=torch.float)
                    new_pair[k] = pad_matrix(arr_t, max_height, max_width)
                result[key][phase].append(new_pair)
    return result

def pad_all_solutions(data_dict, max_height, max_width):
    result = {}
    for key, section in data_dict.items():
        result[key] = []
        for arr in section:
            arr_t = torch.tensor(arr, dtype=torch.float)
            result[key].append(pad_matrix(arr_t, max_height, max_width))
    return result

# insert data in list
result_datasets = []
for data in [train_challenges, eval_challenges, test_data]:
    padded_data_challenges = pad_all_challenges(data, max_hight, max_weight)
    result_datasets.append(padded_data_challenges)

for data in [train_solutions, eval_solutions]:
    padded_data_solutions = pad_all_solutions(data, max_hight, max_weight)
    result_datasets.append(padded_data_solutions)

train_challenges, eval